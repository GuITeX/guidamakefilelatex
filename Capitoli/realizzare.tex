\cleardoublepage
\chapter{Realizzare un \texttt{Makefile}}
\label{cha:realizzare-makefile}

\section{Le regole}
\label{sec:le-regole}

Un \texttt{Makefile} basilare è composto essenzialmente da \emph{regole}
(chiamate in inglese \emph{rules}) che hanno la seguente struttura:
\begin{lstlisting}[showtabs=true,tab=\rightarrowfill,caption={Struttura di una
regola.},label=lst:rule]
obiettivo: prerequisiti
	comandi
	...
	...
\end{lstlisting}
L'\emph{obiettivo} (in inglese \emph{target}), ciò che viene scritto prima dei
due punti \texttt{:}, di norma è il nome del file che verrà generato con la
regola descritta.  Nel paragrafo~\ref{sec:phony} vedremo come usare un obiettivo
che non sia il nome di un file da creare eseguendo la corrispondente regola.

I \emph{prerequisiti} (in inglese \emph{prerequisites}) sono i file che devono
essere presenti al momento dell'esecuzione di una regola e a partire dai quali
viene generato il file obiettivo.  Spesso gli obiettivi dipendono da più file,
che vengono elencati separati da uno spazio.  Per evitare problemi in fase di
compilazione è conveniente che tutti i file non abbiano degli spazi nel proprio
nome.  Le regole possono non avere alcun prerequisito.

Il programma \texttt{make} conosce i comandi necessari per eseguire una regola
leggendoli dall'elenco dei \emph{comandi}.  I comandi di ciascuna regola
\emph{devono necessariamente} essere preceduti da una tabulazione (nel
codice~\ref{lst:rule} è evidenziata dalla freccia
\lstinline[showtabs=true,tab=\rightarrowfill]{	}), non da spazi altrimenti
verrà segnalato un errore.

Un \texttt{Makefile} deve contenere almeno una regola, ma possono essercene
anche più di una, ciascuna corrispondente a un diverso file da creare, e
l'ordine con cui le regole compaiono nel \texttt{Makefile} \emph{non} è
importante.

Un \texttt{Makefile} può contenere anche dei commenti, introdotti dal simbolo
cancelletto \texttt{\#}: tutto ciò che si trova alla destra di \texttt{\#} sulla
sua stessa riga viene trattato come commento.  Questo simbolo ha lo stesso
comportamento del simbolo \texttt{\%} nel linguaggio \LaTeX{}.

Se lo si desidera è possibile suddividere una riga di codice molto lunga su più
righe inserendo \texttt{\textbackslash{}} seguito da un carattere di nuova linea
(in pratica bisogna premere il tasto \keys{Invio} subito dopo l'inserimento del
backslash).  Ciò non è obbligatorio, in quanto non sono posti limiti alla
lunghezza delle righe di un \texttt{Makefile}, però può aiutare la leggibilità
del codice.


\section{Come funziona \texttt{make}}
\label{sec:come-funziona}

Tutta la logica di funzionamento di \texttt{make} si basa sul fatto che gli
obiettivi dipendono dai prerequisiti:
\emph{quando un prerequisito viene modificato allora probabilmente l'obiettivo
  deve essere ricreato}.
Questo meccanismo, forse un po' laborioso e difficile da comprendere
inizialmente, dovrebbe risultare chiaro più avanti.

Per eseguire la regola che ha per obiettivo il file \texttt{<obiettivo>} bisogna
invocare \texttt{make} da terminale con il comando
\begin{verbatim}
$ make <obiettivo>
\end{verbatim} % $
\texttt{make} verifica se è necessario aggiornare l'obiettivo della regola
corrispondente in questo modo: se l'obiettivo indicato da linea di comando non
esiste oppure ha una data di ultima modifica precedente almeno a una di quelle
dei file elencati nei \emph{prerequisiti} è considerato da aggiornare e la
regola viene eseguita.  In caso contrario (l'obiettivo esiste ed è più recente
di tutti i prerequisiti) la regola non viene eseguita e sul terminale si leggerà
il messaggio
\begin{verbatim}
make: Nessuna operazione da eseguire per "<obiettivo>".
\end{verbatim}
Le istruzioni per aggiornare un obiettivo sono
presenti nei \emph{comandi}: questi sono passati alla shell, normalmente la
\texttt{sh}.

\begin{figure}
  \centering
  \begin{tikzpicture}[level 1/.style={sibling distance=100},
    edge from parent/.style={draw,<-}]
    \node[rounded corners,draw] {\texttt{obiettivo1}}
         child { node {\texttt{prerequisito1}}}
         child { node[rounded corners,draw] {\texttt{prerequisito2}}
           child {node {\texttt{prerequisito3}}}
         };
  \end{tikzpicture}
  \caption{Grafo ad albero che illustra le dipendenze fra i file.  I file che si
    trovano alla punta di una freccia, evidenziati in un rettangolo,
    costituiscono l'obiettivo di una regola, i file che invece si trovano alla
    coda di una freccia rappresentano i prerequisiti della corrispondente
    regola e sono necessari per la creazione dell'obiettivo.}
  \label{fig:grafo-albero1}
\end{figure}
Poiché tutta la logica di funzionamento di \texttt{make} è basata sulle
dipendenze fra i file, per scrivere correttamente un \texttt{Makefile} risulta
utile disegnarsi un grafo ad albero che illustri le relazioni che ci sono fra i
vari file, individuando quali dovranno essere gli obiettivi delle regole e quali
saranno i prerequisiti delle regole.  Uno stesso file può svolgere il ruolo di
prerequisito in una regola e di obiettivo in un'altra.  Nell'esempio della
figura~\ref{fig:grafo-albero1} ci sono due obiettivi, \texttt{obiettivo1} e
\texttt{prerequisito2}, per le quali verranno scritte le opportune regole.  I
prerequisiti di \texttt{obiettivo1} sono i file \texttt{prerequisito1} e
\texttt{prerequisito2}, l'unico prerequisito di \texttt{prerequisito2} è il file
\texttt{prerequisito3}.

Prima di eseguire una regola \texttt{make} verifica se è necessario aggiornare
uno o più dei file elencati fra i prerequisiti e in questo caso esegue
automaticamente le eventuali regole associate ai prerequisiti.  Nel seguente
\texttt{Makefile}, corrispondente alla situazione illustrata nella
figura~\ref{fig:grafo-albero1},
\begin{lstlisting}
obiettivo1: prerequisito1 prerequisito2
	comando1
	comando2

prerequisito2: prerequisito3
	comando3
\end{lstlisting}
il \texttt{prerequisito2} ha una propria regola: dando il comando
\begin{verbatim}
$ make obiettivo1
\end{verbatim} % $
\texttt{make} verifica se è necessario aggiornare, eseguendo in maniera
automatica il \texttt{comando3} specificato, il file \texttt{prerequisito2}
prima di eseguire la regola associata all'\texttt{obiettivo1}.  Uno dei pregi di
\texttt{make} è che esso si occupa autonomamente di eseguire tutte le regole che
servono per preparare i prerequisiti dell'obiettivo che si vuole creare,
\texttt{obiettivo1} nell'esempio.  Per la buona riuscita di questo processo è
cruciale la corretta e completa definizione delle dipendenze fra i file.

Se si richiama \texttt{make} senza argomenti, cioè si dà solo il comando
\begin{verbatim}
$ make
\end{verbatim} % $
esso procede all'esecuzione della prima regola che trova nel \texttt{Makefile},
per la precisione la prima regola il cui target non inizia con un punto \texttt{.}
(questo comportamento può essere modificato, vedi \textcite[5]{gnu:make}).

Se si vuole forzare l'esecuzione delle regola \texttt{<obiettivo>}, ignorando le
date di modifica dell'obiettivo e dei suoi prerequisiti, bisogna utilizzare
l'opzione \texttt{-B} in questo modo:
\begin{verbatim}
$ make -B <obiettivo>
\end{verbatim} % $

\section{Un semplice \texttt{Makefile}}
\label{sec:makefile-semplice}

Passiamo ora alla pratica vedendo un esempio di \texttt{Makefile} molto semplice
per compilare un documento \LaTeX{}.
Supponiamo che il sorgente sia interamente contenuto nel solo file
\texttt{documento.tex} e che vogliamo generare il file di output in formato DVI.
Se il documento non contiene bibliografia, indice, indice analitico, ecc., per
fare questo è sufficiente eseguire il comando
\begin{verbatim}
$ latex documento
\end{verbatim} % $
Il \texttt{Makefile} che descrive questa regola è il seguente
\begin{lstlisting}[caption={Un semplice \texttt{Makefile}.},label=lst:base]
documento.dvi: documento.tex
	latex documento
\end{lstlisting}
Nel codice~\ref{lst:base}, il file \texttt{documento.dvi} è l'\emph{obiettivo},
cioè il file ottenuto dopo la compilazione, il \emph{prerequisito} è il solo
file \texttt{documento.tex} e l'unico comando che deve essere eseguito è
\texttt{latex documento}.  Per generare il file di output \texttt{documento.dvi}
bisogna eseguire il comando
\begin{verbatim}
make documento.dvi
\end{verbatim}
oppure semplicemente \texttt{make} se la regola è la prima in ordine di
apparizione nel \texttt{Makefile}.

\section{Un \texttt{Makefile} un po' più elaborato}
\label{sec:makefile-elaborato}

Se nel nostro file di esempio \texttt{documento.tex} è presente una bibliografia
realizzata con \textsc{Bib}\TeX, per compilare il documento è necessario (vedi
\textcite[120]{pantieri:latex}) eseguire i comandi
\begin{verbatim}
$ latex documento
$ bibtex documento
$ latex documento
$ latex documento
\end{verbatim}
Ripetere questi cinque comandi ogni volta che si desidera compilare un documento
può diventare un'operazione noiosa.  Già in questo caso si intravede l'utilità
di \texttt{make}.  Nel \texttt{Makefile} si deve utilizzare la seguente regola
\begin{lstlisting}
documento.dvi: documento.tex bibliografia.bib
	latex documento
	bibtex documento
	latex documento
	latex documento
\end{lstlisting}
in cui i prerequisiti sono il file principale \texttt{documento.tex} e il file
in cui abbiamo scritto la nostra base di dati dei riferimenti bibliografici.
Questi file sono modificati manualmente dall'autore del documento, non devono
essere ricreati da programmi esterni, quindi non sono presenti regole associate
a questi prerequisiti.  Per compilare il documento è sufficiente dare il comando
\begin{verbatim}
$ make documento.dvi
\end{verbatim} % $
oppure solo \texttt{make} qualora quella regola fosse la prima presente nel
\texttt{Makefile}.

Si può anche mettere una regola per compilare lo stesso documento con \LaTeX{}
e un'altra per compilarlo con \textsc{PDF}\LaTeX, per poter scegliere fra un
file di output in formato \textsc{DVI} o \textsc{PDF}.  In questo caso il
\texttt{Makefile} apparirebbe così:
\begin{lstlisting}[caption={La prima regola permette di compilare un documento con
\LaTeX, la seconda con \textsc{PDF}\LaTeX.},label=lst:dvi-pdf]
documento.dvi: documento.tex bibliografia.bib
	latex documento
	bibtex documento
	latex documento
	latex documento

documento.pdf: documento.tex bibliografia.bib
	pdflatex documento
	bibtex documento
	pdflatex documento
	pdflatex documento
\end{lstlisting}

In alcune distribuzioni GNU/Linux sono presenti gli script \texttt{texi2dvi} e
\texttt{texi2pdf} che eseguono rispettivamente \LaTeX{}
e \textsc{PDF}\TeX{}
(e, se necessario, \textsc{Bib}\TeX) sul sorgente il numero strettamente
necessario di volte per la corretta compilazione del documento (vedi
\textcite[63]{caucci:tabelle}).  Utilizzando questi due comandi il
codice~\ref{lst:dvi-pdf} si potrebbe ridurrebbe quindi a
\begin{lstlisting}
documento.dvi: documento.tex bibliografia.bib
	texi2dvi documento

documento.pdf: documento.tex bibliografia.bib
	texi2pdf documento
\end{lstlisting}
Anche lo script \texttt{latexmk}, fornito dalle distribuzioni TeX Live e MikTeX,
offre funzionalità simili, bisogna però evidenziare che se il documento richiede
comandi particolari per la compilazione (come quando si utilizza il pacchetto
\verb|frontespizio|), \verb|texi2dvi|, \verb|texi2pdf| e \verb|latexmk| non sono
più in grado di generare correttamente il documento finale, a meno di istruirli
opportunamente.

\section{Phony target}
\label{sec:phony}

È possibile specificare delle regole che non hanno come obiettivo il nome del
file che verrà ottenuto.  Questo tipo di obiettivi vengono chiamati in inglese
\emph{phony targets} (cioè \emph{falsi obiettivi}).  Spesso i phony target hanno
come nome dei comandi. Per esempio, quando si esegue la regola
\begin{lstlisting}
clean:
	rm -f *.aux *.log *.out
\end{lstlisting}
vengono cancellati tutti i file con estensione \verb|.aux|, \verb|.log| e
\verb|.out| che vengono prodotti durante la compilazione di un semplice
documento
\LaTeX.\footnote{Il comando \texttt{rm} cancella tutti i file che vengono
  elencati di seguito, l'opzione \texttt{-f} serve per non stampare eventuali
  messaggi di errore in caso di assenza dei file da cancellare.  Il
  metacarattere \texttt{*} sostituisce una qualsiasi sequenza di caratteri.}
È consigliabile specificare esplicitamente quali sono i phony target utilizzati
nel \verb|Makefile|: se nella cartella in cui si trova il \verb|Makefile| è
presente un file chiamato \verb|clean| questa regola non verrebbe mai eseguita.
Infatti, dal momento che la regola non ha prerequisiti, il file \texttt{clean}
risulterebbe sempre aggiornato (vedi \textcite[31]{gnu:make}).  Per fare ciò
bisogna mettere gli obbiettivi di queste regole come prerequisiti della regola
speciale \verb|.PHONY|:
\begin{lstlisting}
.PHONY: clean
clean:
	rm -f *.aux *.log *.out
\end{lstlisting}
In questo modo \verb|make| sa che \verb|clean| non è il nome del file che si
deve ottenere e la regola verrà quindi sempre eseguita, indipendentemente dalla
presenza di un eventuale file \verb|clean|.

I phony target possono essere anche usati per creare una sorta di \emph{alias}
di altre regole.  Per esempio, inserendo il seguente
\begin{lstlisting}[caption={I prerequisiti della regola dell'obiettivo
\texttt{.PHONY} sono i nomi dei phony target che vengono successivamente
specificati.},label=lst:phony]
.PHONY: dvi pdf

dvi: documento.dvi

pdf: documento.pdf
\end{lstlisting}
in un \verb|Makefile|, prima del codice~\ref{lst:dvi-pdf}, per compilare il
documento in formato \textsc{DVI} si potrà eseguire il comando
\begin{verbatim}
make dvi
\end{verbatim}
Analogamente, per ottenere il file \textsc{PDF} si potrà dare il comando
\begin{verbatim}
make pdf
\end{verbatim}
L'utilità dell'uso di questi alias è che i comandi da eseguire sono indipendenti
dal nome del file di output.

Accanto al phony target \verb|clean| si trova spesso \verb|distclean|:
\verb|clean| cancella solo i file temporanei generati durante la compilazione,
\verb|distclean| in più elimina anche i file di output (quindi gli eventuali
file in formato \verb|.pdf| o \verb|.dvi|, nel caso di documenti
\LaTeX).\footnote{Queste sono solo delle convenzioni, in uso specialmente
  nell'ambito della programmazione.  L'utente è libero di creare regole diverse
  e con nomi differenti.}
Poiché \verb|distclean|, \emph{oltre} a cancellare file rimossi da \verb|clean|
ne cancella altri, è possibile inserire \verb|clean| come prerequisito di
\verb|distclean|, in modo che quella regola venga eseguita \emph{anche} quando
si dà il comando \verb|make distclean|:
\begin{lstlisting}[caption={Phony target \texttt{distclean} e \texttt{clean}.},
label=lst:distclean]
.PHONY: distclean clean

distclean: clean
	rm -f *.pdf *.dvi

clean:
	rm -f *.aux *.log *.out
\end{lstlisting}


\section{Le variabili}
\label{sec:variabili}

Uno dei punti di forza dell'utilizzo di \verb|make| per compilare documenti
\LaTeX{}
è che una volta che si possiede un \verb|Makefile| ben organizzato per compilare
un documento, con pochissime modifiche si può adattare alla compilazione di un
altro documento, strutturato in maniera simile.  Ciò è reso ancora più facile
dall'uso delle variabili.

Una variabile è un nome a cui è associato un \emph{valore} che in genere è una
stringa di testo.  Per assegnare a una variabile il suo valore si usa la
sintassi
\begin{lstlisting}
VARIABILE = valore
\end{lstlisting}
Le variabili permettono di rendere il \verb|Makefile| più compatto perché i
valori delle variabili sono spesso dei lunghi elenchi di file che dovrebbero
essere ripetuti più volte all'interno del file: invece di scrivere ogni volta
questa lunga stringa è sufficiente richiamare il valore della variabile che sarà
poi automaticamente sostituito da \verb|make| durante la processazione del file.
Inoltre quando diventa necessario modificare uno di questi elenchi, è
sufficiente modificare solo una volta il valore della variabile, senza dover
andare a cercare nel file tutte le occorrenze da sostituire.

Le variabili, \emph{dopo} essere state dichiarate, possono essere referenziate
usando il simbolo del dollaro seguito (senza spazi) da parantesi tonde o graffe:
\begin{lstlisting}
$(VARIABILE)
${VARIABILE}
\end{lstlisting}
Per evitare di dimenticarsi di dichiarare una variabile prima di richiamarla può
essere utile abituarsi a definire tutte le variabili all'inizio del
\verb|Makefile|.

Le variabili possono essere referenziate in qualsiasi parte di un
\verb|Makefile|, come per esempio negli obiettivi, nei prerequisiti, nei
comandi, nel valore di altre variabili.  Le variabili possono rappresentare
qualsiasi cosa: oltre a elenchi di file le variabili potrebbero avere come
valore nomi di cartelle in cui cercare file o programmi da eseguire.

Le variabili, come qualunque altra cosa scritta nel \verb|Makefile|, sono
sensibili alle maiuscole, quindi \verb|Variabile|, \verb|variabile| e
\verb|VARIABILE| sono stringhe distinte.  Inoltre il nome di una variabile può
essere una sequenza di qualsiasi carattere eccetto spazi o tabulazioni, siano
essi iniziali o finali, o uno fra i tre seguenti simboli \verb|:| \verb|#|
\verb|=|.  È comunque consigliabile utilizzare per i nomi delle variabili solo
lettere, numeri e trattini bassi, vedi \textcite[57]{gnu:make}.  Eventuali
caratteri di spaziatura o tabulazione presenti prima o dopo il nome di una
variabile vengono ignorati, come nel codice~\ref{lst:variabili}.

Vediamo ora un'applicazione dell'uso delle variabili.  Consideriamo il caso in
cui abbiamo un documento \LaTeX{}
principale chiamato \verb|documento.tex|, nel quale abbiamo inserito un indice
analitico e una bibliografia realizzata con \textsc{Bib}\TeX{}
e che l'elenco dei libri consultati si trovi nel file \verb|bibliografia.bib|.
Entrambi i file \verb|documento.tex| e \verb|bibliografia.bib|, inoltre, si
trovano nella stessa cartella in cui è posizionato il seguente
\verb|Makefile|:\footnote{Parte del \texttt{Makefile} è ripreso da quello
  presente in \textcite[61]{caucci:tabelle}.}
\begin{lstlisting}[caption={Esempio di \texttt{Makefile} che utilizza le
variabili.},label=lst:variabili]
PRINCIPALE 		= documento
PRINCIPALE_TEX		= $(PRINCIPALE).tex
PRINCIPALE_DVI		= $(PRINCIPALE).dvi
PRINCIPALE_PDF		= $(PRINCIPALE).pdf
BIBLIOGRAFIA		= bibliografia
BIBLIOGRAFIA_BIB	= $(BIBLIOGRAFIA).bib
FILE_CLEAN		= *.aux *.bbl *.blg *.brf *.idx \
			  *.ilg *.ind *.log
FILE_DISTCLEAN		= $(PRINCIPALE_DVI) \
			  $(PRINCIPALE_PDF)

.PHONY: dvi pdf distclean clean

dvi: $(PRINCIPALE_DVI)

pdf: $(PRINCIPALE_PDF)

$(PRINCIPALE_DVI): $(PRINCIPALE_TEX) $(BIBLIOGRAFIA_BIB)
	latex $(PRINCIPALE)
	bibtex $(PRINCIPALE)
	makeindex $(PRINCIPALE)
	latex $(PRINCIPALE)
	latex $(PRINCIPALE)

$(PRINCIPALE_PDF): $(PRINCIPALE_TEX) $(BIBLIOGRAFIA_BIB)
	pdflatex $(PRINCIPALE)
	bibtex $(PRINCIPALE)
	makeindex $(PRINCIPALE)
	pdflatex $(PRINCIPALE)
	pdflatex $(PRINCIPALE)

distclean: clean
	rm -f $(FILE_DISTCLEAN)

clean:
	rm -f $(FILE_CLEAN)
\end{lstlisting}
Le variabili specificate all'inizio del file vengono sostituite da \verb|make|
quando viene invocato: tutte le occorrenze di
\verb|$(PRINCIPALE)| verranno lette dal programma come se ci fosse scritto
\verb|documento|, perciò la variabile \verb|$(PRINCIPALE_TEX)|
assume il valore \verb|documento.tex|, e così via. Come nell'esempio del
codice~\ref{lst:phony}, per compilare il documento in formato \textsc{DVI} è
sufficiente dare il comando
\begin{verbatim}
make dvi
\end{verbatim}
e per ottenere un documento \textsc{PDF} bisogna invece utilizzare il comando
\begin{verbatim}
make pdf
\end{verbatim}

Nella variabile \verb|$(FILE_CLEAN)|
abbiamo indicato tutti i file che dovranno essere cancellati nella regole
\verb|clean|, analogamente la variabile \verb|FILE_DISTCLEAN| assume come valore
i nomi dei file \verb|documento.dvi| e \verb|documento.pdf| che verranno rimossi
se si esegue il comando \verb|make distclean|.  Notare che, come nel
codice~\ref{lst:distclean}, \verb|clean| è un prerequisito di \verb|distclean|.

Quando si dovrà compilare un documento \LaTeX{}
che richiede gli stessi comandi del documento appena visto, si potrà facilmente
riutilizzare lo stesso \verb|Makefile|, avendo solo cura di modificare il valore
delle variabili \verb|PRINCIPALE| e \verb|BIBLIOGRAFIA| a seconda delle
necessità. % Il \verb|Makefile| va sempre posto o copiato nella cartella in cui
% si trova il nuovo documento.

Esistono delle cosiddette funzioni per nomi di
file.\footnote{Per un elenco esaustivo di queste funzioni vedi
  \textcite[83]{gnu:make}.} Fra tutte ne ricordiamo una:
\begin{lstlisting}
$(wildcard modello)
\end{lstlisting}
Al posto di \verb|modello| bisogna inserire uno schema di nome di file,
generalmente contenente un metacarattere. Per esempio, con
\begin{lstlisting}
$(wildcard *.tex)
\end{lstlisting}
si indica un elenco di tutti i file, presenti nella cartella, con estensione
\verb|.tex|.  Risulta particolarmente utile per ottenere un elenco di file che
hanno tutti uno stesso formato o uno stesso schema nel nome.

Un ultimo strumento importante sono le funzioni per le sostituzioni di
stringhe.\footnote{Per un elenco esaustivo di queste funzioni vedi
  \textcite[80]{gnu:make}.}  In particolare la funzione
\begin{lstlisting}
$(patsubst modello,sostituzione,testo)
\end{lstlisting}
permette di sostituire \verb|modello| con \verb|sostituzione| all'interno di
\verb|testo|.  \verb|modello| potrebbe contenere il metacarattere \verb|%| che
rappresenta una qualsiasi sequenza di caratteri e numeri.  Se anche
\verb|sostituzione| contiene \emph{la stessa} sequenza indicata da \verb|%|
allora la sostituzione viene eseguita.  Per esempio
\begin{lstlisting}
$(patsubst %.png,%.eps,img1.png img2.jpg img3.png)
\end{lstlisting}
viene interpretato da \verb|make| come
\begin{verbatim}
img1.eps img3.eps
\end{verbatim}
\verb|img2.jpg| non ha lo stesso schema di \verb|modello|, non finisce cioè per
\verb|.png|, e quindi la sostituzione non avviene, ma le altre due parole
seguono lo schema del modello per cui \verb|img1.png| e \verb|img3.png| vengono
sostituite rispettivamente con \verb|img1.eps| e \verb|img3.eps|.

\subsection{Uso delle variabili nelle regole}
\label{sec:uso-variabili}

Abbiamo imparato che per richiamare una variabile definita all'interno del
\verb|Makefile| bisogna usare la sintassi
\verb|$(NOME_DELLA_VARIABILE)|.  Qualche volta, però, potremmo voler richiamare
una variabile della shell.  Nella maggior parte delle shell Unix questo si fa
usando proprio il metacarattere \verb|$|,
però per far capire a \verb|make| che in questo caso vogliamo una variabile
della shell e non del \verb|Makefile| dobbiamo raddoppiare il simbolo di dollaro
\verb|$|: \verb|$$|.

Nel seguente esempio, tratto da~\textcite[43]{gnu:make},
\begin{lstlisting}
ELENCO = uno due tre
foo:
	for i in $(ELENCO); do \
	  echo $$i; \
	done
\end{lstlisting}
la variabile \verb|ELENCO| è stata richiamata normalmente con
\verb|$(ELENCO)| poiché è una variabile del \verb|Makefile|, mentre la variabile
\verb|i| del \verb|for| è stata richiamata con \verb|$$i|
poiché è una variabile della shell.

Osserviamo che in un \verb|Makefile| i comandi che devono essere eseguiti in una
regola vanno scritti, normalmente, uno su ciascuna riga.  Anche se generalmente
i cicli \verb|for| delle shell Unix sono scritti nella forma
\begin{lstlisting}[language=bash]
for <variabile> in <elenco>; do
  comandi
  ...
  ...
done
\end{lstlisting}
si tratta in realtà di \emph{un unico} comando e quindi nel \verb|Makefile|
andrebbe scritto su un'unica riga in questo modo
\begin{lstlisting}[language=bash]
for <variabile> in <elenco>; do comandi ; ... ; ... ; done
\end{lstlisting}
Per rendere il codice più leggibile si può effettuare l'escape del carattere di
nuova linea (vedi paragrafo~\ref{sec:le-regole}) come fatto nell'esempio
precedente.  Bisogna prendere questo accorgimento anche quando in una regola si
vogliono eseguire gli altri tipi di cicli e verifiche condizionali delle shell
quali \verb|if|, \verb|while| e \verb|until|.

\subsection{Sostituzione di comando}
\label{sec:sostituzione-comando}

Nella principali shell Unix si può effettuare la sostituzione di comando con la
sintassi \verb|`...`| e questa può essere usata anche all'interno di un
\verb|Makefile|.  Inoltre nella bash e nella ksh la sostituzione di comando può
essere eseguita con la sintassi \verb|$(...)| che però nei \verb|Makefile|
abbiamo visto che si usa per richiamare il valore delle variabili.  La
sostituzione di comando può essere eseguita, invece, sfruttando la funzione
\verb|shell| in questo modo:
\begin{lstlisting}
$(shell <comando>)
\end{lstlisting}
sostituendo a \verb|<comando>| l'effettivo comando da eseguire.  Il comando
viene passato alla shell impostata con la variabile \verb|SHELL| che in maniera
predefinita è la \verb|sh|.

Per esempio, se si vuole impostare una variabile che sia uguale alla data
attuale si può usare una delle due seguenti alternative
\begin{lstlisting}
ORA = `date "+%Y%m%d-%H%M%S"`
ORA = $(shell date "+%Y%m%d-%H%M%S")
\end{lstlisting}
L'argomento di \verb|date| può, naturalmente, essere cambiato in modo da
adattarlo alle proprie esigenze.

\section{Un \texttt{Makefile} ancora più complesso}
Il codice~\ref{lst:variabili} è già un \verb|Makefile| abbastanza elaborato e
utile per automatizzare comandi piuttosto lunghi.

Quando in un documento si inseriscono delle immagini, queste devono avere un
formato particolare a seconda che si compili il documento con \LaTeX{}
o con \textsc{PDF}\LaTeX.  In particolare, \LaTeX{}
richiede immagini in formato \textsc{EPS}, \textsc{PDF}\LaTeX{}
accetta immagini in formato \textsc{PDF}, \textsc{JPG} e \textsc{PNG} (vedi
\textcite[105]{pantieri:latex}).  Se si possiede un'immagine in un formato
diverso da quello necessario per l'inserimento nel documento, si deve quindi
procedere alla conversione da un formato all'altro.  Il programma
\verb|ImageMagick| fornisce il comando da terminale \verb|convert|. Con la
sintassi
\begin{verbatim}
convert fileinput fileoutput
\end{verbatim}
si converte il primo file specificato, cioè \verb|fileinput|, nel secondo file,
chiamato in questo caso \verb|fileoutput|.  Il formato dei due file, di input e
output, viene riconosciuto dalle estensioni dei file.  Per esempio, il comando
\begin{verbatim}
convert nomefile.eps nomefile.pdf
\end{verbatim}
converte il file \verb|nomefile.eps|, in formato \textsc{EPS}, nel file
\verb|nomefile.pdf|, in formato \textsc{PDF}.  Supponiamo di avere nella
sottocartella \verb|Immagini| della cartella in cui si trovano il documento
\LaTeX{}
principale e il \verb|Makefile| tutte le immagini in formato \textsc{PDF}.  Per
compilare in \textsc{DVI} è quindi necessario convertire tutte le immagini.  Per
automatizzare la compilazione e la conversione delle immagini è possibile
scrivere queste regole utilizzando le funzioni apprese nel
paragrafo~\ref{sec:variabili}:
\begin{lstlisting}[caption={\texttt{Makefile} in cui le immagini \textsc{PDF}
vengono convertite in \textsc{EPS} nella compilazione con \LaTeX.},label=lst:pdf-eps]
PRINCIPALE 		= documento
PRINCIPALE_TEX		= $(PRINCIPALE).tex
PRINCIPALE_DVI		= $(PRINCIPALE).dvi
BIBLIOGRAFIA		= bibliografia
BIBLIOGRAFIA_BIB	= $(BIBLIOGRAFIA).bib
TUTTI_LATEX		= $(PRINCIPALE_TEX) \
			  $(BIBLIOGRAFIA_BIB)
CARTELLA_IMG		= Immagini
IMMAGINI_PDF		= $(wildcard $(CARTELLA_IMG)/*.pdf)
IMMAGINI_EPS		= $(patsubst $(CARTELLA_IMG)/%.eps,\
			  $(CARTELLA_IMG)/%.pdf, $(IMMAGINI_PDF))

.PHONY: dvi immagini-eps

dvi: $(PRINCIPALE_DVI)

$(PRINCIPALE_DVI): $(TUTTI_LATEX) immagini-eps
	latex $(PRINCIPALE)
	bibtex $(PRINCIPALE)
	makeindex $(PRINCIPALE)
	latex $(PRINCIPALE)
	latex $(PRINCIPALE)

immagini-eps: $(IMMAGINI_EPS)

Immagini/%.eps: Immagini/%.pdf
	convert $^ $@
\end{lstlisting}
La variabile \verb|IMMAGINI_PDF| contiene l'elenco di tutti i file in formato
\textsc{PDF} presenti nella sottocartella Immagini (il nome della sottocartella
è salvato nella variabile \verb|CARTELLA_IMG| in modo che sarà sufficiente
cambiare solo questo valore per cartelle con nomi differenti).  La variabile
\verb|IMMAGINI_EPS|, invece, contiene l'elenco dei degli stessi file in formato
\textsc{PDF}, ma questa volta con estensione \verb|.eps| (abbiamo utilizzato la
funzione \verb|patsubst| per eseguire la sostituzione).  In questo
\verb|Makefile| è presente una regola con una definizione un po' particolare:
\begin{lstlisting}
Immagini/%.eps: Immagini/%.pdf
	convert $^ $@
\end{lstlisting}
Il prerequisito di questa regola è un qualsiasi file della sottocartella
\verb|Immagini| con estensione \verb|.pdf|, l'obiettivo, però, non è un
qualsiasi file della sottocartella \verb|Immagini| con estensione \verb|.eps|,
bensì il file che ha lo stesso nome base del prerequisito ed estensione
\verb|.eps|.\footnote{Il metacarattere \texttt{\%} è stato introdotto nel
  paragrafo~\ref{sec:variabili}.}
Con questa regola verranno dunque generati solo file con estensione \verb|.eps|
e nome base uguale a quello di file in formato \textsc{PDF} presente nella
sottocartella \verb|Immagini|.  Il comando eseguito nella regola è
\begin{lstlisting}
	convert $^ $@
\end{lstlisting}
Le due variabili \verb|$^| e \verb|$@| sono delle variabili dette automatiche%
\footnote{Per un elenco esaustivo di queste variabili vedi
  \textcite[112]{gnu:make}.}
e che hanno un significato speciale: la prima indica tutti i prerequisiti della
regola (in questo caso indica solo il file \textsc{PDF} che ha lo stesso nome
dell'obiettivo), la seconda indica l'obiettivo della regola (in questo caso
l'immagine \textsc{EPS} da generare).  Se volessimo convertire un determinato
file chiamato, supponiamo, \verb|immagine.pdf| in formato \textsc{EPS} potremmo
utilizzare il comando nel terminale:
\begin{verbatim}
make immagine.eps
\end{verbatim}
Per come è scritta la regola con obiettivo \verb|$(PRINCIPALE_DVI)|
nel \verb|Makefile| del codice~\ref{lst:pdf-eps} non è però necessario
convertire una a una le immagini quando si vuole generare il documento in
formato \textsc{DVI}.  Infatti, compilando con il comando
\begin{verbatim}
make dvi
\end{verbatim}
il programma \verb|make| si preoccupa di verificare se tutti i prerequisiti
elencati in questa regola sono aggiornati.  Uno di essi è \verb|immagini-eps|
che è un phony target: \verb|immagini-eps| ha il compito di convertire tutte le
immagini in formato \textsc{PDF} presenti nella sottocartella \verb|Immagini|
nel formato \textsc{EPS}, adatto per l'inclusione di immagini nel documento
finale \textsc{DVI}.

Riportiamo ora un \verb|Makefile| ancora più complesso di quelli visti fino ad
adesso. Immaginiamo di avere in una cartella il file \verb|documento.tex| come
file \LaTeX{}
principale, \verb|bibliografia.bib| come raccolta dei riferimenti bibliografici.
Nella sottocartella \verb|Capitoli| sono presenti vari file \verb|.tex| inclusi
in \verb|documento.tex|; nella sottocartella \verb|Immagini|, invece, sono
presenti immagini nel solo formato \textsc{PDF} che saranno eventualmente
convertite nel formato \textsc{EPS} nel caso di compilazione con \LaTeX.  Un
\verb|Makefile| per compilare questo progetto potrebbe apparire così:
\begin{lstlisting}[caption={Un \texttt{Makefile} complesso.},
label=lst:complesso]
PRINCIPALE 		= documento
PRINCIPALE_TEX		= $(PRINCIPALE).tex
PRINCIPALE_DVI		= $(PRINCIPALE).dvi
PRINCIPALE_PDF		= $(PRINCIPALE).pdf
CAPITOLI_TEX		= $(wildcard Capitoli/*.tex)
BIBLIOGRAFIA		= bibliografia
BIBLIOGRAFIA_BIB	= $(BIBLIOGRAFIA).bib
TUTTI_LATEX		= $(PRINCIPALE_TEX) \
			  $(BIBLIOGRAFIA_BIB) \
			  $(CAPITOLI_TEX)
IMMAGINI_PDF		= $(wildcard Immagini/*.pdf)
IMMAGINI_EPS		= $(patsubst Immagini/%.eps,\
			  Immagini/%.pdf, $(IMMAGINI_PDF))
FILE_CLEAN		= *.aux *.bbl *.blg *.brf *.idx \
			  *.ilg *.ind *.log
FILE_DISTCLEAN		= $(PRINCIPALE_DVI) \
			  $(PRINCIPALE_PDF) \
			  $(IMMAGINI_EPS)

.PHONY: dvi pdf distclean clean immagini-eps

dvi: $(PRINCIPALE_DVI)

pdf: $(PRINCIPALE_PDF)

$(PRINCIPALE_DVI): $(TUTTI_LATEX) immagini-eps
	latex $(PRINCIPALE)
	bibtex $(PRINCIPALE)
	makeindex $(PRINCIPALE)
	latex $(PRINCIPALE)
	latex $(PRINCIPALE)

$(PRINCIPALE_PDF): $(TUTTI_LATEX) $(IMMAGINI_PDF)
	pdflatex $(PRINCIPALE)
	bibtex $(PRINCIPALE)
	makeindex $(PRINCIPALE)
	pdflatex $(PRINCIPALE)
	pdflatex $(PRINCIPALE)

immagini-eps: $(IMMAGINI_EPS)

Immagini/%.eps: Immagini/%.pdf
	convert $^ $@

distclean: clean
	rm -f $(FILE_DISTCLEAN)

clean:
	rm -f $(FILE_CLEAN)
\end{lstlisting}
\begin{figure}
  \centering
  \begin{tikzpicture}[level 1/.style={sibling distance=90},
    edge from parent/.style={draw,<-}]
    \node (dvi) [rounded corners,draw] {\texttt{\$(PRINCIPALE\_DVI)}}
      child {node {\texttt{\$(TUTTI\_LATEX)}}}
      child {node[rounded corners,draw] {\texttt{\$(IMMAGINI\_EPS)}}
        child {node {\texttt{\$(IMMAGINI\_PDF)}}}
      };
    \node at ($(dvi)+(7,0)$) [rounded corners,draw]
      {\texttt{\$(PRINCIPALE\_PDF)}}
      child {node {\texttt{\$(TUTTI\_LATEX)}}}
      child {node {\texttt{\$(IMMAGINI\_PDF)}}};
  \end{tikzpicture}
  \caption{Grafo ad albero che rappresenta le dipendenze fra i file del
    \texttt{Makefile} del codice~\ref{lst:complesso}, eccetto i phony target.}
  \label{fig:grafo-albero2}
\end{figure}
Con gli strumenti acquisiti fino a questo punto dovrebbe essere comprensibile
come funziona questo \verb|Makefile|, cosa compie ciascuna regola e quali
comandi bisogna dare nel terminale per compilare il documento.  Per maggiore
chiarezza, nella figura~\ref{fig:grafo-albero2} è rappresentato il grafo ad
albero che descrive le dipendenze fra i file del \verb|Makefile| mostrato nel
codice~\ref{lst:complesso}.

\section{Conclusione}
\label{sec:conclusione}
% TODO: scrivere qualcos'altro oppure cancellare questo paragrafo

I \verb|Makefile| dei programmi spesso raggiungono svariate migliaia di righe di
codice, per quanto riguarda un documento \LaTeX{}
piuttosto complesso ne possono bastare anche poche decine.  Si possono comunque
realizzare dei \verb|Makefile| molto più lunghi e avanzati di quelli visti in
questa guida.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../make"
%%% End:
